# 1. 브라우저와 동작원리

## ⓐ 브라우저가 무엇일까?
- 월드와이드웹(WWW)에서 정보를 검색, 표현, 탐색하기 위한 소프트웨어를 의미합니다. 브라우저의 핵심 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것입니다.

- 브라우저는 HTML과 CSS 명세 (웹 표준화 기구인 W3C(World Wide Web Consortium)에서 정해진 명세) 에 따라 HTML 파일을 해석해서 표시합니다.

## ⓑ 브라우저의 역할
- 첫째, 사용자가 입력한(원하는) 웹페이지, 이미지, 동영상 등의 자원을 서버에게 요청하는 역할을 수행합니다.

- 둘째, 서버로부터 전달(응답)받은 자원을 화면에 출력하는 역할을 수행합니다.

## ⓒ 브라우저 구조

<img src="https://user-images.githubusercontent.com/76525368/129310978-457fe83d-5648-4219-871e-ddf38b9d3f39.png" width="450px">

- **UI(User Interface) :** 사용자가 접근할 수 있는 영역입니다.<br>
사용자 인터페이스 주소 표시 줄, 이전/다음 버튼, 새로 고침, 정지, 홈 버튼 등이 있습니다.

- **Broweser Engine :**  사용자 인터페이스와 렌더링 엔진사이의 동작을 제어해주는 엔진입니다.
 <br>브라우저라는 프로그램의 비즈니스 로직, 핵심 중추 부분입니다.
 <br>Data Storage를 참조하며 로컬에 데이터를 쓰고 읽으면서 다양한 작업을 수행합니다.

- **Rendering Engine :** 렌더링 엔진 요청한 콘텐츠를 브라우저 화면에 표시하고,  HTML과 CSS를 파싱하여 웹페이지를 화면에 표시합니다.
- **Networking 네트워크 :** HTTP 요청과 같은 네트워크 호출에 사용 및 각종 네트워크 요청을 수행하고 서버와 통신합니다.

- **JavaScript Interpreter :** 자바스크립트 해석기, 자바스크립트 코드를 실행하는 인터프리터를 의미합니다.<br>
 ㉠ JavaScript는 렌더링 엔진이 아닌 JavaScript Interpreter가 처리합니다.
  - HTML 파서는 script태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘깁니다.

  - 제어 권한을 넘겨받은 자바스크립트 엔진은 script태그 내의 자바스크립트 코드 나 script태그의 src에 정의된 js 파일을 로드하고 파싱하여 실행합니다.

  - 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨 브라우저가 중지했던 시점부터 DOM 생성을 재개합니다.<br>
 그러므로 HTML 요소를 다 처리한 이후, 자바스크립트를 처리할 수 있도록 body태그 하단에 script태그를 위치시키는 것이 좋습니다.

  ㉡ JavaScript 코드는 body 태그 하단에 위치하면 script 로딩 지연으로 인해 동기적으로 동작하는 브라우저 동작에 blocking이 발생하지 않아 페이지 로딩 시간이 단축됩니다.

  ㉢ CSS 코드는 head 태그 안에 위치하여 렌더링 처리 시에 브라우저가 더 빨리 참고할 수 있게 하는 것이 좋습니다.

- **UI Backend :** UI를 처리할 수 있는 백엔드 영역를 의미합니다.

- **Data Persistence :** 자료 저장소, 자료를 저장하는 계층를 의미하며<br>
localStorage나 Cookie와 같이 보조 기억장치에 데이터를 저장하는 파트입니다.

## ⓓ 브라우저 렌더링 과정

<img src="https://user-images.githubusercontent.com/76525368/129313001-50073261-7b79-4219-84d4-41ba9301fa51.png">

 **1. DOM tree 생성**
 - 브라우저의 렌더링 엔진이 HTML 코드를 읽고 파싱하여 DOM tree를 생성합니다.<br>
  ㉠ HTML 코드를 어휘분석을 통해 HTML5 표준에 정된 고유한 토큰으로 변환합니다.<br>
  ㉡ 렉싱과정을 통해 토큰을 해당 속성과 규칙을 정의하는 NODE로 변환합니다.<br>
  ㉢ 각 NODE가 서로 연관성을 가질 수 있도록 DOM tree를 생성합니다.

**2. Render tree 생성**
- 화면에 표시 되어야 할 모든 Node의 컨텐츠, 스타일 정보를 포함하는 tree를 의미합니다.<br>
  ㉠ CSS 파일이나 HTML에 inline으로 작성된 스타일 코드를 파싱하여 CSSOM을 구성합니다.<br>
  ㉡ document부터 각 Node를 순회하면서 각각에 맞는 CSSOM을 찾아 규칙을 적용합니다.<br>
  ㉢ DOM 트리와 CSSOM을 결합하여 Render tree를 생성합니다.<br>
  ㉣ meta 태그나 display : none 속성을 가진 요소들은 렌더와 무관하므로 Render tree에 포함되지 않습니다.

**3. Layout(reflow)**
- 뷰포트 내에 생성된 render tree의 각 노드들의 정확한 위치와 크기를 결정합니다.<br>
 ㉠ %, em과 같은 상대 단위를 사용했을 때 뷰포트에 맞춰 px로 변환합니다.

**4. Paint(repaint)**
- 마지막으로 구성한 레이아웃을 실제로 화면에 픽셀로 그리는 과정입니다.

## ⓔ 브라우저가 화면을 다시 그리는 경우

<img src="https://user-images.githubusercontent.com/76525368/129318981-f5171657-4e4f-4511-bf2a-34c7eb6adc52.png">

- **다시 Layout이 발생하거나 주로 요소의 크기나 위치가 바뀔 때, 혹은 브루어 창의 크기가 바뀌었을 때 다시 발생합니다.**<br>
→ 레이아웃 수치를 다시 계산해서 배치를 해야하기 때문에, 레이아웃 과정이 다시 발생하고, 페인트와 레이어 합성과정까지 다시 거쳐야합니다.

- **Paint부터 다시 발생하는 경우는 주로 배경 이미지나 텍스트 색상, 그림자 등 레이아웃의 수치를 변화시키지 않는 스타일의 변경이 일어났을 때 발생합니다.**<br>
→ 레이아웃 과정이 다시 발생하지 않기 때문에 성능상으로 조금 더 이점을 가질 수 있습니다.

- **레이어의 합성만 다시 발생하는 경우는 레이어의 합성만 발생하기 때문에 성능적으로 가장 큰 이점을 가집니다.**<br>
→ 레이어는 포토샵의 레이어와 비슷하게 페인팅할 영역을 나누어 놓은 것을 의미합니다.<br>
Chrome의 경우에는 레이아웃 과정 이후에 정해진 기준이나 필요에 의해 브라우저가 레이어를 생성합니다.<br>
렌더링 엔진이 각 레이어를 프린팅 과정에서 각각 그려준 다음에 1개의 비트맵으로 합성하여 페이지를 생성합니다.





